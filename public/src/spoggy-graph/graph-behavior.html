


<script>
  /* @polymerMixin */
  var GraphBehaviorMixin = Polymer.dedupingMixin(function(superClass){
    return class GraphBehavior extends superClass {
      constructor() {
        super();
      }
      static get properties() {
        return {
          test: {
            type: String,
            value: 'spoggy-graph behavior'
          },
          network: {
            type: Object,
            notify: true
          },
          init: {
            type: Object,
            value : {}
          },
          clusters: {
            type: Array,
            value: []
          }
        };
      }



      /////////////////////////////////
      ////// AVANT PERSEE , fonctions a nettoyer...
      /////////////////////////////////



      clusterLessCid(cid, label){
        console.log("CLUSTER Less CID")
        for (var i = 1; i <= cid-1; i++) {
          this.makeClusters(i, label);
        }
      }


      // make the clusters
      makeClusters(clusterIndex, label) {
        var app = this;
        var clusterOptionsByData = {
          processProperties: function (clusterOptions, childNodes) {
            var childrenCount = 0;
            for (var i = 0; i < childNodes.length; i++) {
              childrenCount += childNodes[i].childrenCount || 1;
            }
            clusterOptions.childrenCount = childrenCount;
            clusterOptions.label = label +"\n #" + clusterIndex + "\n (" + childrenCount + ")";
            clusterOptions.id = 'cluster:' + clusterIndex;
            app.clusters.push({id:'cluster:' + clusterIndex});
            return clusterOptions;
          },
          joinCondition:function(childOptions) {
            return childOptions.cid == clusterIndex;
          },
          clusterNodeProperties: {borderWidth: 3, shape: 'star', color: 'rgb(255,255,0)'}, // font: {size: 30}
        }
        this.network.cluster(clusterOptionsByData);
        /*if (document.getElementById('stabilizeCheckbox').checked === true) {
        network.stabilize();
      }*/
    }

    /*
    clusterByCid() {
    console.log("CLUSTER BY ID")
    //  this.network.setData(data);
    var clusterOptionsByData = {
    joinCondition:function(childOptions) {
    return childOptions.cid == 1;
  },
  clusterNodeProperties: {id:'cidCluster', borderWidth:3, shape:'database'}
};
this.network.cluster(clusterOptionsByData);
}
clusterOtherCid(cid) {
console.log("CLUSTER BY OTHER ID")
//  this.network.setData(data);
var clusterOptionsByData = {
joinCondition:function(childOptions) {
console.log(childOptions)
return childOptions.cid == cid ;
},
clusterNodeProperties: {id:'cidCluster_'+cid, borderWidth:3, shape:'database'}
};
this.network.cluster(clusterOptionsByData);
}

clusterByHubsize() {
//  this.network.setData(data);
var clusterOptionsByData = {
processProperties: function(clusterOptions, childNodes) {
clusterOptions.label = "[" + childNodes.length + "]";
return clusterOptions;
},
clusterNodeProperties: {borderWidth:3, shape:'database', font:{size:30}}
};
this.network.clusterByHubsize(undefined, clusterOptionsByData);
}
*/


addResultsToGraph(network, results){
  var app = this;
  var nodes = results.nodes;
  var edges = results.edges;
  console.log(nodes);
  console.log(edges);
  nodes.forEach(function(n){
    app.addNodeIfNotExist(app.network, n);
  });
  edges.forEach(function(e){
    //  app.addEdgeIfNotExist(app.network, e)
    var existEdge = false;
    //  console.log(e);
    try {
      existEdge = app.network.body.data.edges.get({
        filter: function(edge){
          return (edge.id == e.id) || ((edge.from == e.from) && (edge.to == e.to) && (edge.label == e.label));
        }
      });
      if (existEdge.length == 0){
        app.network.body.data.edges.add(e);
      }else{
        //  this.network.body.data.edges.update({id: data[0].id, label: data[0].label});
        console.log("le lien existe déjà ??? Dois-je augmenter son poids ?")
      }
    }
    catch (err) {
      console.log(err);
    }
  });
}

/////////////////////////////////
////// APRES PERSEE
/////////////////////////////////


resultsFromExplore(results){
  console.log("POPULATE From Sparql");
  console.log(results)
  var app = this;

  this.addResultsToGraph(app.network, results)
  //  network.body.data.nodes.clear();
  //  network.body.data.edges.clear();
  //app.addNodeIfNotExist(app.network, nodes);
  //app.addEdgeIfNotExist(app.network, edges);

  /*Object.keys(results).forEach(function(id) {

});*/
}

clear(){
  console.log("clear")
  this.network.body.data.nodes.clear();
  this.network.body.data.edges.clear();
}






importFromParam(params){
  console.log("\nPARAMS :",params);
  var app = this;
  //
  if(params.uri != undefined && params.endpoint!= undefined){
    console.log("URI = "+params.uri);
    console.log("ENDPOINT: "+params.uri);
    this.agentGraph.send('agentVirtuoso', {type: "uriEndpoint", params:params});
  }else{
    console.log("PARAMETRES");
    var source = params.source;
    var remplaceNetwork = params.remplaceNetwork || false;

    var network = this.network;
    var output = [];
    var xhr = new XMLHttpRequest();
    xhr.open('GET', source, true);
    xhr.responseType = 'blob';
    xhr.onload = function(e) {
      //  console.log(e);
      var reponse = e.target.response;
      //  console.log(reponse);
      var reader = new FileReader(); //https://openclassrooms.com/courses/dynamisez-vos-sites-web-avec-javascript/l-api-file
      reader.addEventListener('load', function () {
        //  console.log(reader.result);
        // ajouter test en fonction du type de fichier, extension
        var extension = source.split('.').pop();

        if ((extension == "json") || (reader.result.startsWith("[{"))) {

          var nodes = JSON.parse(reader.result).nodes;
          console.log(nodes);
          var edges = JSON.parse(reader.result).edges;
          console.log(edges);
          network.beforeImport = [];
          network.beforeImport.nodes = network.body.data.nodes.get();
          network.beforeImport.edges = network.body.data.edges.get();
          //  network.body.data.nodes.update(nodes);
          //  network.body.data.edges.update(edges);
          try{
            console.log("update")
            console.log(nodes)
            network.body.data.nodes.update(nodes);
            network.body.data.edges.update(edges);
            console.log(network.body.data.nodes)
            console.log(network.body.data.edges)
          }
          catch(e){
            console.log("erreur")
            console.log(e);
          }
        }else{
          //console.log("ce type de fichier n'est pas pris en compte (" + fichier.type + ")");

          console.log(extension);
          //  console.log(fichier);
          //  console.log(reader.result);
          if ((extension == "ttl") || (extension == "n3") || (extension == "n3t")) {
            //   sketch.ttl2Xml(reader.result);
            ttl2Xml(reader.result, network, remplaceNetwork);
            //  network.dispatch('addTriplets', network.triplets);
          } else if ((extension == "rdf") || (extension == "owl")) {
            //  sketch.data2Xml(reader.result); //if srdf
            rdf2Xml(reader.result, network, remplaceNetwork);
            //  network.dispatch('addTriplets', network.triplets);
          }
          else {
            ttl2Xml(reader.result, network, remplaceNetwork);
            //  data2Xml(reader.result, network);
          }
          console.log("fichier lu");

        }
        //  console.log(network);
        //  console.log(partageImport);
        network.fit();
        network.redraw();
        console.log(network.body.data.nodes)
        console.log(network.body.data.edges)
      });
      reader.readAsText(reponse);
    };
    xhr.send();
  }

  //  this.agentGraph.send('agentCurrent', {type: "hasParams", params:params});
}

addToGraph(data){
  console.log(data)
  var app = this;
  if (data.actions.length>0){
    data.actions.forEach(function(action) {
      console.log(action);
      console.log(app.network)
      switch(action.type) {
        case "newNode":
        if(app.network != undefined){
          app.addNodeIfNotExist(app.network, action.data);
        }
        break;
        case "editNode":
        break;
        case "deleteNode":
        app.deleteFromServer(action.data);
        break;
        case "newEdge":
        if(app.network != undefined){
          app.addEdgeIfNotExist(app.network, action.data);
        }
        break;
        case "editEdge":
        break;
        case "deleteEdge":
        app.deleteFromServer(action.data);
        break;
        default:
        console.log("action non reconnue");
        console.log(action);
      }
    });
  }
}

resultsFromPersee(message){
  console.log("POPULATE From Persee");


  var app = this;
  let network = this.network;
  //  network.body.data.nodes.clear();
  //  network.body.data.edges.clear();
  console.log(message.results)
  //  console.log(message.typeResource);
  for(var r in message.typeResource){
    //  alert(propt + ': ' + obj[propt]);
    let nResource = {
      id: message.typeResource[r],
      label: message.typeResource[r]
    }
    let idRes = network.body.data.nodes.update(nResource)[0];
  }
  let nodes = message.results.nodes;
  network.body.data.nodes.update(nodes);
  network.body.data.edges.update(message.results.edges);
  console.log(network.body.data);
}





resultsFromSparql(results){
  console.log("POPULATE From Sparql");
  console.log(results)
  var app = this;
  let network = this.network;
  //  network.body.data.nodes.clear();
  //  network.body.data.edges.clear();

  Object.keys(results).forEach(function(id) {
    var data = results[id];
    //  console.log(id);
    //  console.log(data)
    if (data.type == "node"){
      //A Modifier dans statements-behaviors pour envoyer dans un tableau de nodes !
      //  console.log("NONONONODE")
      network.body.data.nodes.update(data);
    }
    if (id == "edges"){
      //    console.log("EDGEEDGEDGE")
      data.forEach(function(e){
        //  console.log(e);
        //network.body.data.edges.update(e);

        var edge = network.body.data.edges.get({
          filter: function(edge) {
            return (edge.from == e.id && edge.to == e.id && edge.label == e);
          }
        });

        if (edge.length == 0){
          network.body.data.edges.update(e);
        }else{
          console.log('le lien existe déjà')
        }

      });
    }
    if (id == "nodes"){
      //    console.log("EDGEEDGEDGE")
      data.forEach(function(n){
        //  console.log(e);
        let type = n.type;

        var ntype = network.body.data.nodes.get({
          filter: function(node){
            //    console.log(node);
            return (node.label == n.type );
          }
        });
        if (ntype.length == 0){
          ntype[0] = network.body.data.nodes.add({label: n.type });
        }
        //  let ntypeId = network.body.data.nodes.update(n);
        let nodeId = network.body.data.nodes.update(n);
        let nZ = nodeId[0];
        let tZ = ntype[0][0] || ntype[0].id;
        //    console.log(nZ);
        //  console.log(tZ);

        let e = {from: nZ, to: tZ, label: 'type'};
        //  console.log(e)
        //   TEST  POR SUPPRIMER DOUBLONS TYPE
        network.body.data.edges.update(e);
      });
    }
  });
  network.fit();
  network.redraw();
}

populateVis(db) {
  console.log("POPULATE");
  let network = this.network;
  network.body.data.nodes.clear();
  network.body.data.edges.clear();
  if (db.length > 0) {
    if (db.length % 100 < 5) {
      /*
      Rezoom tous les 100*/
      network.fit();
      network.redraw();
    }
    var nodes = [];
    var edges = [];
    var reste = [];
    db.forEach(function(t){
      if(t.predicate == "type" && t.object == "node"){
        nodes.push(t.subject);
        network.body.data.nodes.add({id: t.subject, type: t.object, y:2*Math.random()});
      }else if(t.predicate == "type" && t.object == "edge"){
        edges.push(t.subject);
      }  else{ reste.push(t);  }
    });
    reste.forEach(function(r){
      if (nodes.includes(r.subject)){
        var n = {id : r.subject}
        n[r.predicate] = r.object;
        network.body.data.nodes.update(n);
      }else if(edges.includes(r.subject)){
        var e = {id : r.subject}
        e[r.predicate] = r.object;
        network.body.data.edges.update(e);
      }else{
        console.log("Probleme non pris en compte : ")
        console.log(r)
      }
    });

    console.log(network)

    /*
    for (var i = 0; i < 10; i++) {
    var triplet = db.pop();
    if (triplet != undefined) {
    console.log(triplet);
    if (triplet.predicate == "type"  && triplet.object == "node") {
    console.log("NODE : "+triplet.subject);
    var noeudExist = network.body.data.nodes.get(triplet.subject);
    console.log(noeudExist)
    if (noeudExist == null || noeudExist.length == 0) {
    if (triplet.object.length > 40) {
    network.body.data.nodes.add({
    id: triplet.subject,
    label: triplet.object.match(/.{1,40}/g).join("\n"),
    //  shape: "box",
    group: 0
  });
} else {
var node = {
id: triplet.subject,
label: triplet.object,
type: triplet.type,
group: 0,
};
network.body.data.nodes.add(node);
if ((node.label.toLowerCase() == "depart") || (node.label.toLowerCase() == "départ")) {
//  console.log('trouve depart');
//var nodeDep = network.body.data.nodes.get(triplet.subject);
//console.log(nodeDep);
//nodeDep.color = {background:'pink', border:'purple'};
network.body.data.nodes.update({
id: triplet.subject,
color: {
background: 'pink',
border: 'purple'
}
})
var nodeDep = network.body.data.nodes.get(triplet.subject);
//nodeDep = network.body.data.nodes.get(triplet.subject);
network.focus(nodeDep.id);
network.fit();
}

}
} else {

network.body.data.nodes.update({
id: triplet.subject,
label: triplet.object,
type: triplet.type,
})
}
} else if (triplet.type == "shape") {
console.log(triplet);
network.body.data.nodes.update({
id: triplet.subject,
shape: triplet.object
})
}
else if (triplet.type == "color") {
console.log(triplet);
network.body.data.nodes.update({
id: triplet.subject,
color: triplet.object
})
}       else {
var edgeExist = [];
edgeExist = network.body.data.edges.get(triplet.subject);
if (edgeExist == null || edgeExist.length == 0) {
var edge = {
id: "",
from: "",
to: "",
label: "",
arrows: "to"
};
edge.id = triplet.subject;
edge[triplet.predicate] = triplet.object;
network.body.data.edges.add(edge);
} else {
var edge = edgeExist;
edge[triplet.predicate] = triplet.object;
network.body.data.edges.update(edge);
}
}
} else {
console.log("import terminé")
//  network.focus(nodeDep);
clearInterval(this.tickInterval);
var app = this;
console.log("revoir app.eyedata = app.network.body.data")

}
}*/
}
}





deleteFromServer (data){
  console.log("delete ")
  console.log(data)
  //Pour suppression, on recupere le noeud et ses liens envoyés par le serveur
  this.network.body.data.nodes.remove(data.nodes);
  this.network.body.data.edges.remove(data.edges);
}

describeFromDBpedia(results, resource){
  let app = this;
  console.log(results)
  let res = resource.split("#");
  //  console.log(conceptCut);
  let labelRes = res[res.length-1];
  if (labelRes == resource){
    res = resource.split("/");
    //console.log(conceptCut);
    labelRes = res[res.length-1];
  }
  results.forEach(function(r){
    console.log(r);
    let s,o;
    let p = r.p.value;
    if (r.s == undefined){
      s = labelRes;
    }else{
      s  = r.s.value;
    }
    if (r.o == undefined){
      o = labelRes;
    }else{
      o = r.o.value;
    }
    console.log(s +" "+p+" "+o)

    //recherche de noeuds existants
    var sujetNode = app.network.body.data.nodes.get({
      filter: function(node){return (node.label == s );}})[0];
      var objetNode = app.network.body.data.nodes.get({
        filter: function(node){return (node.label == o);}})[0];

        // sinon, on les créé
        if (sujetNode == undefined){
          let sArray = s.split("#");
          //  console.log(conceptCut);
          let labelS = sArray[sArray.length-1];
          if (labelS == s){
            sArray = s.split("/");
            //console.log(conceptCut);
            labelS = sArray[sArray.length-1];
          }
          sujetNode =  app.network.body.data.nodes.add({label: labelS, title: s, type: "node", y:2*Math.random() });
        }
        if (objetNode == undefined){
          let labelO = o;
          let shape = "ellipse";

          if (r.o.type == 'uri'){
            let oArray = o.split("#");
            //  console.log(conceptCut);
            labelO = oArray[oArray.length-1];
            if (labelO == o){
              oArray = o.split("/");
              //console.log(conceptCut);
              labelO = oArray[oArray.length-1];
            }
          }else{
            //literal
            shape ="box"
            if (o.length > 40) {
              labelO =  o.substring(0,40),
              o = o.match(/.{1,40}/g).join("\n")

            }
          }
          objetNode = app.network.body.data.nodes.add({label: labelO, title: o, type: "node", shape:shape, y:2*Math.random() });
        }
        console.log(sujetNode);
        console.log(objetNode);
        let pArray = p.split("#");
        //  console.log(conceptCut);
        let labelP = pArray[pArray.length-1];
        if (labelP == p){
          pArray = p.split("/");
          //console.log(conceptCut);
          labelP = pArray[pArray.length-1];
        }
        let edge = {
          title: p,
          label: labelP,
          from : sujetNode[0] || sujetNode.id,
          to : objetNode[0] || sujetNode.id,
          type: "edge",
        }
        console.log(edge)
        app.network.body.data.edges.add(edge);


      });
    }


    updateNetworkOptions(settings){
      console.log(settings)
      if(settings.centralGravity!= undefined){
        this.network.physics.options.repulsion.centralGravity = settings.centralGravity;
      }
      if(settings.springLength!= undefined){
        this.network.physics.options.repulsion.springLength = settings.springLength;
      }
      if(settings.springConstant!= undefined){
        this.network.physics.options.repulsion.springConstant = settings.springConstant;
      }
      if(settings.nodeDistance!= undefined){
        this.network.physics.options.repulsion.nodeDistance = settings.nodeDistance;
      }
      if(settings.damping!= undefined){
        this.network.physics.options.repulsion.damping = settings.damping;
      }
      console.log(this.network.physics.options.repulsion)
    }

    resetNetworkOptions(){
      this.network.physics.options.repulsion.centralGravity = this.centralGravityValueDefault;
      this.network.physics.options.repulsion.springLength = this.springLengthValueDefault;
      this.network.physics.options.repulsion.springConstant = this.springConstantValueDefault;
      this.network.physics.options.repulsion.nodeDistance = this.nodeDistanceValueDefault;
      this.network.physics.options.repulsion.damping = this.dampingValueDefault;
      console.log(this.network.physics.options.repulsion)
    }



    catchTriplet(message){
      // A REVOIR ET REMPLACER PAR catchTripletsV2() ??
      //  console.log(message.length);
      //message=message.trim();
      //  var tripletString = message.substring(2).trim().split(" ");
      //  var tripletString = message.trim().split(" ");
      // les noeuds existent-ils ?
      var sujetNode = this.network.body.data.nodes.get({
        filter: function(node){
          //    console.log(node);
          return (node.label == message[0] );
        }
      });
      if (sujetNode.length == 0){
        this.network.body.data.nodes.add({label: message[0], type: "node", x:2*Math.random(), y:2*Math.random() });
      }
      var objetNode = this.network.body.data.nodes.get({
        filter: function(node){
          //    console.log(node);
          return (node.label == message[2]);
        }
      });
      //  console.log(sujetNode);
      //  console.log(objetNode);
      // sinon, on les créé

      if (objetNode.length == 0){
        this.network.body.data.nodes.add({ label: message[2], type: "node", x:-2*Math.random(), y:-2*Math.random() });
      }
      // maintenant ils doivent exister, pas très po=ropre comme méthode , à revoir
      sujetNode = this.network.body.data.nodes.get({
        filter: function(node){
          return (node.label == message[0] );
        }
      });
      objetNode = this.network.body.data.nodes.get({
        filter: function(node){
          return (node.label == message[2]);
        }
      });
      var actionSujet = {};
      actionSujet.type = "newNode";
      actionSujet.data = sujetNode[0];
      //  actionsToSendTemp.push(actionSujet);
      //    this.addAction(actionSujet);

      var actionObjet = {};
      actionObjet.type = "newNode";
      actionObjet.data = objetNode[0];
      //  actionsToSendTemp.push(actionObjet);
      //  this.addAction(actionObjet);


      // maintenant, on peut ajouter l'edge
      this.network.body.data.edges.add({
        label: message[1],
        from : sujetNode[0].id,
        to : objetNode[0].id,
        type: "edge",
      });

      //on récupère ce edge pour l'envoyer au serveur
      var edge = this.network.body.data.edges.get({
        filter: function(edge) {
          return (edge.from == sujetNode[0].id && edge.to == objetNode[0].id && edge.label == message[1]);
        }
      });
      var actionEdge = {};
      actionEdge.type = "newEdge";
      actionEdge.data = edge;
      //  this.addAction(actionEdge);
      let actionstosend = [];
      actionstosend.push(actionSujet);
      actionstosend.push(actionObjet);
      actionstosend.push(actionEdge);
      this.agentGraph.send('agentSocket', {type: "newActions", actions: actionstosend});
      this.agentGraph.send('agentSparqlUpdate', {type: "newActions", actions: actionstosend});
      console.log(sujetNode[0])
      //this.network.redraw();
      this.network.moveTo({    position: {x:0, y:0}});
      /*  this.network.moveTo({
      position: {x:sujetNode[0].x, y:sujetNode[0].y},
      scale: 1,
      offset: {x:20, y:20},
      animation: {
      duration: 3,
      easingFunction: 'easeInOutCubic'
    }
  });*/

  //  actionsToSendTemp.push(actionEdge);
  //console.log(actionsToSendTemp);
  //  return actionsToSendTemp;
}


exportJsonSolid() {
  var network = this.network;
  console.log(network)
  var textToWrite = "";
  //  var fileNameToSaveAs = filename+"_spoggy_nodes_edges_" + Date.now() + ".json";
  //var textFileAsBlob = "";

  console.log("export Json");
  console.log(network.body.data);
  var nodes_edges = { nodes: network.body.data.nodes.get(), edges: network.body.data.edges.get() };
  console.log(nodes_edges);
  var nodes_edgesJSON = JSON.stringify(nodes_edges);
  console.log(nodes_edgesJSON);
  /*textFileAsBlob = new Blob([nodes_edgesJSON], {
  type:
  'application/json'
}
);*/

this.agentGraph.send('agentDialogs', {type:'exportJsonSolid', jsonData : nodes_edgesJSON});

}



exportJson() {
  var network = this.network;
  console.log(network)
  var filename = prompt("Sous quel nom sauvegarder ce graphe ?", "Spoggy");
  //  app.$.inputMessage.value = '';
  if (filename == null || filename == "") {
    txt = "User cancelled the prompt.";
    return;
  }
  var textToWrite = "";
  var fileNameToSaveAs = filename+"_spoggy_nodes_edges_" + Date.now() + ".json";
  var textFileAsBlob = "";

  console.log("export Json");
  console.log(network.body.data);
  var nodes_edges = { nodes: network.body.data.nodes.get(), edges: network.body.data.edges.get() };
  console.log(nodes_edges);
  var nodes_edgesJSON = JSON.stringify(nodes_edges);
  console.log(nodes_edgesJSON);
  textFileAsBlob = new Blob([nodes_edgesJSON], {
    type:
    'application/json'
  }
  );
  var downloadLink = document.createElement("a");
  downloadLink.download = fileNameToSaveAs;
  downloadLink.innerHTML = "Download File";
  if(navigator.userAgent.indexOf("Chrome") != -1)
  {
    // Chrome allows the link to be clicked
    // without actually adding it to the DOM.
    console.log("CHROME");
    downloadLink.href = window.URL.createObjectURL(textFileAsBlob);
  } else
  {
    // Firefox requires the link to be added to the DOM
    // before it can be clicked.
    console.log("FF");
    downloadLink.href = window.URL.createObjectURL(textFileAsBlob);
    downloadLink.target="_blank";
    //downloadLink.onclick = destroyClickedElement;
    //downloadLink.onclick = window.URL.revokeObjectURL(downloadLink);
    downloadLink.style.display = "none";
    document.body.appendChild(downloadLink);
    //  console.log(app.$.popupTtl);
  }
  console.log(downloadLink);
  /*downloadLink.click();*/
  /* creation d'un event car download.click() ne fonctionne pas sous Firefox */
  var event = document.createEvent("MouseEvents");
  event.initMouseEvent(
  "click", true, false, window, 0, 0, 0, 0, 0
  , false, false, false, false, 0, null
  );
  downloadLink.dispatchEvent(event);
  var app = this;
  setTimeout(function(){
    console.log(downloadLink.parentNode);
    document.body.removeChild(downloadLink);
    window.URL.revokeObjectURL(downloadLink);
  }, 1000);
  /*if (window.URL != null) {
  // Chrome allows the link to be clicked
  // without actually adding it to the DOM.
  downloadLink.href = window.URL.createObjectURL(textFileAsBlob);
} else {
// Firefox requires the link to be added to the DOM
// before it can be clicked.
downloadLink.href = window.URL.createObjectURL(textFileAsBlob);
downloadLink.onclick = destroyClickedElement;
downloadLink.style.display = "none";
document.body.appendChild(downloadLink);
}
downloadLink.click();*/
}



exportTtl() {
  /* source https://github.com/scenaristeur/dreamcatcherAutonome/blob/master/autonome/public/agents/ExportAgent.js */
  let network = this.network;
  var nodes = network.body.data.nodes.get();
  var edges = network.body.data.edges.get();
  console.log("exportation");
  console.log(nodes);
  console.log(edges);
  //creation des statements (triplets)
  /*var statements = [];
  for (var j = 0; j < edges.length; j++){
  var edge = edges[j];
  console.log(edge);
  statements.push({sujet: node.id, propriete: "rdfs:label", objet: node.label});
}
console.log(statements);*/

var output = "@prefix : <http://smag0.blogspot.fr/spoggy#> . \n";
output += "@prefix owl: <http://www.w3.org/2002/07/owl#> . \n";
output += "@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> . \n";
output += "@prefix xml: <http://www.w3.org/XML/1998/namespace> . \n";
output += "@prefix xsd: <http://www.w3.org/2001/XMLSchema#> . \n";
output += "@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> . \n";
output += "@prefix smag: <http://smag0.blogspot.fr/spoggy#> . \n";
output += "@base <http://smag0.blogspot.fr/spoggy> . \n";
output += "<http://smag0.blogspot.fr/spoggy> rdf:type owl:Ontology ;  \n";
output += "                    owl:versionIRI <http://smag0.blogspot.fr/spoggy/1.0.0> . \n";
output += " \n";
output += "owl:Class rdfs:subClassOf owl:Thing .  \n";

var listeInfos = new Array();
var listeComplementaire = new Array();

for (var i = 0; i < edges.length; i++) {
  var edge = edges[i];

  var sujet = edge.from;
  var propriete = edge.label.replace(/\s/g, "_");
  var objet = edge.to;


  //string.indexOf(substring) > -1
  //console.log(sujet);
  //console.log(propriete);
  //  console.log(objet);

  // AJOUTER EVENTUELLEMENT LA RECUPERATION DE SHAPE, COLOR, pour l'export RDF
  var sujetLabel = network.body.data.nodes.get(sujet).label;
  var objetLabel = network.body.data.nodes.get(objet).label;
  //console.log("#########################");
  //console.log(sujetLabel);
  //console.log(objetLabel)
  //console.log("#########################");

  var sujetWithPrefix = this.validRdf(network, sujet);
  var proprieteWithPrefix = this.validRdf(network, propriete);
  var objetWithPrefix = this.validRdf(network, objet);

  if (sujetWithPrefix.indexOf(':') == -1) { // ne contient pas de ':'
  sujetWithPrefix = '_:' + sujetWithPrefix; // blanknode
}

if (proprieteWithPrefix.indexOf(':') == -1) { // ne contient pas de ':'
proprieteWithPrefix = ':' + proprieteWithPrefix; // propriete utilisant "@base <http://smag0.blogspot.fr/spoggy>"

}

if (objetWithPrefix.indexOf(':') == -1) { // ne contient pas de ':'
objetWithPrefix = '_:' + objetWithPrefix;  // blanknode
}


var typedeProp = ["owl:AnnotationProperty", "owl:ObjectProperty", "owl:DatatypeProperty"];
var indiceTypeDeProp = 1; // -1 pour ne pas ajouter la prop, sinon par defaut en annotationProperty, 1 pour Object, 2 pour Datatype --> revoir pour les datatypes

if (
(proprieteWithPrefix == "type") ||
(proprieteWithPrefix == ":type") ||
(proprieteWithPrefix == "rdf:type") ||
(proprieteWithPrefix == ":a") ||
(proprieteWithPrefix == ":est_un") ||
(proprieteWithPrefix == ":est_une") ||
(proprieteWithPrefix == ":is_a")
) {
  proprieteWithPrefix = "rdf:type";
  listeComplementaire.push(objetWithPrefix + " rdf:type owl:Class . \n");
  indiceTypeDeProp = 1;
} else if ((proprieteWithPrefix == "subClassOf") || (proprieteWithPrefix == ":subClassOf") || (proprieteWithPrefix == "rdfs:subClassOf")) {
  proprieteWithPrefix = "rdfs:subClassOf";
}
else if ((proprieteWithPrefix == "sameAs") || (proprieteWithPrefix == ":sameAs")) {
  proprieteWithPrefix = "owl:sameAs";
  indiceTypeDeProp = -1;
}
else if (
(proprieteWithPrefix.toLowerCase() == "ispartof") ||
(proprieteWithPrefix.toLowerCase() == "partof") ||
(proprieteWithPrefix.toLowerCase() == ":partof") ||
(proprieteWithPrefix.toLowerCase() == ":ispartof")) {
  proprieteWithPrefix = "smag:partOf";
  indiceTypeDeProp = 1;
} else if (
(proprieteWithPrefix.toLowerCase() == "comment") ||
(proprieteWithPrefix.toLowerCase() == "commentaire") ||
(proprieteWithPrefix.toLowerCase() == "//") ||
(proprieteWithPrefix.toLowerCase() == "#")
) {
  proprieteWithPrefix = "rdfs:comment";
  indiceTypeDeProp = -1;
}
if (indiceTypeDeProp >= 0) {
  listeComplementaire.push(proprieteWithPrefix + " rdf:type " + typedeProp[indiceTypeDeProp] + " . \n");
}
var data = sujetWithPrefix + " " + proprieteWithPrefix + " " + objetWithPrefix + " . \n";
data += sujetWithPrefix + " " + "rdfs:label \"" + sujetLabel + "\" . \n";
data += objetWithPrefix + " " + "rdfs:label \"" + objetLabel + "\" . \n";
listeInfos[i] = data;
console.log(data);
console.log("||||||||||||||||||||||--");
}
//console.log(listeInfos);
//console.log(listeComplementaire);
//suppression des doublons
listeInfos = this.uniq_fast(listeInfos.sort());
listeComplementaire = this.uniq_fast(listeComplementaire.sort());
// console.log (listeInfos);
for (var k = 0; k < listeInfos.length; k++) {
  output = output + listeInfos[k];
  //  console.log(output);
}

for (var l = 0; l < listeComplementaire.length; l++) {
  output = output + listeComplementaire[l];
  //  console.log(output);
}

//this.$.dialogs.$.inputTextToSave.value = output; //     document.getElementById("inputTextToSave").value =output;
/*this.$.dialogs.$.popupTtl.fitInto = this.$.dialogs.$.menu;*/
//this.$.dialogs.$.popupTtl.toggle();
console.log(output)

this.agentGraph.send('agentDialogs', {type:'exportTtl', ttlData : output});
}

uniq_fast(a) {
  var seen = {};
  var out = [];
  var len = a.length;
  var j = 0;
  for(var i = 0; i < len; i++) {
    var item = a[i];
    if(seen[item] !== 1) {
      seen[item] = 1;
      out[j++] = item;
    }
  }
  return out;
}

newGraph(){
  //network.body.data.nodes.clear();
  //network.body.data.edges.clear();
  let network = this.network;

  var graphname = prompt("Comment nommer ce nouveau graphe ?", "Spoggy-Graph_"+Date.now());
  var nodeName = {
    label: graphname,
    shape: "star",
    color: "green",
    type: "node"
  };
  var nodeGraph = {
    label: "Graph",
    /*    shape: "star",
    color: "red",*/
    type: "node"
  };
  network.body.data.nodes.clear();
  network.body.data.edges.clear();
  var nodes = network.body.data.nodes.add([nodeName, nodeGraph]);

  var edge = {
    from: nodes[0],
    to: nodes[1],
    arrows: "to",
    label: "type"
  }
  network.body.data.edges.add(edge);
  /* seulement en cas de synchro, mais difficile de newgrapher en synchro ?
  var action = {};
  action.type = "newNode";
  action.data = nodeName;
  this.addAction(action);

  action = {};
  action.type = "newNode";
  action.data = nodeGraph;
  this.addAction(action);

  action = {};
  action.type = "newEdge";
  action.data = edge;
  this.addAction(action);

  action = {};
  action.type = "changeGraph";
  action.data = graphname;
  this.addAction(action);
  if(app.socket != undefined){
  app.socket.graph = graphname;
  console.log(app.socket);
}
*/

//app.socket.emit('newGraph', graphname);
/*
//document.getElementById('importPopUp').style.display = 'block';
app.$.importPopUp.style.display = 'block';

var filepicker = app.$.filepicker;
filepicker.addEventListener('change', handleFileSelect.bind(app), false);
filepicker.network = network;*/
}

validRdf(network, string){
  // A REVOIR
  console.log(network.body.data.nodes.get(string));
  console.log("nettoyage "+ string);
  // transformer le noeud en noeud rdf (resource ou literal)
  // ajouter la construction du noeud, son uri, prefix, localname, type...
  var valid = {};
  valid.type = "uri";
  if (string.indexOf(" ") !== -1){
    valid.type = "literal";
  }else{
    /*
    replaceAll(string, " ","_");
    replaceAll(string, "","_");
    replaceAll(string, ",","_");
    replaceAll(string, ";","_");
    replaceAll(string, " ","_");*/
  }

  return string;
}


decortiqueFile(fichier, remplaceNetwork){
  //  var network = network;
  //  console.log(network);
  let network = this.network;
  //  console.log(fichier);
  var reader = new FileReader(); //https://openclassrooms.com/courses/dynamisez-vos-sites-web-avec-javascript/l-api-file
  reader.addEventListener('load', function () {
    //  console.log(fichier);
    /*loadstart : La lecture vient de commencer.
    progress : Tout comme avec les objets XHR, l'événement progress se déclenche à intervalles réguliers durant la progression de la lecture. Il fournit, lui aussi, un objet en paramètre possédant deux propriétés, loaded et total, indiquant respectivement le nombre d'octets lus et le nombre d'octets à lire en tout.
    load : La lecture vient de se terminer avec succès.
    loadend : La lecture vient de se terminer (avec ou sans succès).
    abort : Se déclenche quand la lecture est interrompue (avec la méthode abort() par exemple).
    error : Se déclenche quand une erreur a été rencontrée. La propriété error contiendra alors un objet de type FileError pouvant vous fournir plus d'informations.*/
    //    console.log(this.result);
    //alert('Contenu du fichier "' + fichier.name + '" :\n\n' + reader.result);


    switch (fichier.type) {
      case "":
      case "text/plain":
      case "application/json":
      //    console.log("JSON");
      //  thisElement.dispatch('addNodesEdgesJSON', JSON.parse(reader.result));
      //    console.log(network);
      var nodes = JSON.parse(reader.result).nodes;
      //    console.log(nodes);
      var edges = JSON.parse(reader.result).edges;
      //    console.log(edges);
      network.beforeImport = [];
      network.beforeImport.nodes = network.body.data.nodes.get();
      network.beforeImport.edges = network.body.data.edges.get();
      network.body.data.nodes.update(nodes);
      network.body.data.edges.update(edges);
      if(remplaceNetwork){
        console.log(remplaceNetwork);
        network.body.data.nodes.clear();
        network.body.data.edges.clear();
        console.log("clear");
        network.body.data.nodes.add(nodes); // clear() ne semble pas fonctionner, à revoir
        network.body.data.edges.add(edges);
        console.log(network);
      }else{

        try{
          network.body.data.nodes.update(nodes);
          network.body.data.edges.update(edges);
        }
        catch(e){
          console.log(e);
        }
      }
      console.log(network);
      //  console.log(partageImport);
      break;
      case "rdf+xml":
      case "application/rdf+xml":
      console.log("fichier RDF"); //https://github.com/scenaristeur/dreamcatcherAutonome/blob/8376cb5211095a90314e34e9d286b820fbed335b/autonome1/public/agents/FichierAgent.js
      rdf2Xml(reader.result, network);
      //  network.dispatch('addTriplets', network.triplets);// CREER UNE NOUVELLE ACTION POUR ENVOYER TS LES TRIPLETS
      break;
      case "turtle":
      case "text/turtle":
      case "application/turtle":
      console.log("fichier turtle");
      console.log("ce type de fichier n'est pas pris en compte (" + fichier.type + ")");
      ttl2Xml(reader.result, network);
      //network.dispatch('addTriplets', network.triplets);
      break;
      default:
      console.log("ce type de fichier n'est pas pris en compte (" + fichier.type + ")");
      var extension = fichier.name.split('.').pop();
      console.log(extension);
      console.log(fichier);
      //  console.log(reader.result);
      if ((extension == "ttl") || (extension == "n3") || (extension == "n3t")) {
        //   sketch.ttl2Xml(reader.result);
        ttl2Xml(reader.result, network);
        //  network.dispatch('addTriplets', network.triplets);
      } else if ((extension == "rdf") || (extension == "owl")) {
        //  sketch.data2Xml(reader.result); //if srdf
        rdf2Xml(reader.result, network);
        //  network.dispatch('addTriplets', network.triplets);
      }
      else if ((extension == "json") || (reader.result.startsWith("[{"))) {
        // json2Xml(reader.result);
        //  network.dispatch('addNodesEdgesJSON', JSON.parse(reader.result));
      } else {
        ttl2Xml(reader.result, network);
        //data2Xml(reader.result, network);
      }
      console.log("fichier lu");
    }

    // thisApp.dispatch('update_triplets2add', this.triplets2add);

  });
  console.log(fichier);

  reader.readAsText(fichier);
}




shapeIsImage(shape){
  console.log(shape)
  return shape != "image" && shape != "circularImage";
}


//////////////////////////////////////////////////////////////////
networkDivInitialize(container, app){
  console.log(app.centralGravityValueDefault)
  // create an array with nodes
  var nodes = new vis.DataSet([
  {id: "node1", label: 'Spoggy', color: 'rgb(195,238,0)'},
  {id: "node2", label: 'Application Web', color: 'rgba(97,238,195)'},
  {id: "node3", label: 'David'},
  /*  {id: "node4", label: 'Bob'},*/
  {id: "node5", label: 'Graph', color: 'rgba(195,238,97)', cid:2},
  {id: "node6", label: 'Spoggy est une application permettant la création de graphes.', color: 'rgba(238,97,195)', shape: 'box', cid:1},
  /*    {id: "node7", label: 'Description', color: 'rgba(238,97,195,0.5)', cid:1},*/
  {id: "node8", label: 'Un graphe est un ensemble de noeuds\n et de liens entre ces noeuds.', color: 'rgba(238,97,195)', shape: 'box', cid:1},
  /*  {id: "node9", label: 'graph0', color: 'rgba(238,97,195,0.5)', type: 'graph', name: 'graph0'},
  {id: "node10", label: 'graph1', color: 'rgba(238,97,195,0.5)', type: 'graph', name: 'graph1'},
  {id: "node11", label: 'graph2', color: 'rgba(238,97,195,0.5)', type: 'graph', name: 'graph2'},
  {id: "node12", label: 'Input', color: 'rgba(195,238,97,0.5)', cid:2},*/
  ]);
  // create an array with edges
  var edges = new vis.DataSet([
  {from: "node1", to: "node2", label: "type", array:"to"},
  {from: "node1", to: "node3", label: "developpeur", array:"to"},
  //  {from: "node3", to: "node4", label: "connait", array:"to"},
  {from: "node1", to: "node5", label: "utilise", array:"to"},
  //  {from: "node1", to: "node12", label: "hasPart", array:"to"},
  {from: "node1", to: "node6", label: "description", array:"to"},
  //   {from: "node6", to: "node7", label: "type", array:"to"},
  {from: "node5", to: "node8", label: "description", array:"to"},
  /*  {from: "node8", to: "node7", label: "type", array:"to"},
  /    {from: "node9", to: "node5", label: "type", array:"to"},
  {from: "node10", to: "node5", label: "type", array:"to"},
  {from: "node11", to: "node5", label: "type", array:"to"},
  {from: "node1", to: "node9", label: "first", array:"to"},*/

  ]);
  /*var data = {
  nodes: nodes,
  edges: edges
};*/
//  var data = this.init;
var data = {};
var options = {
  locale: 'fr',
  /*configure: {
  enabled: true,
  filter: 'nodes,edges',
  container: settings,
  showButton: true
},*/
edges:{
  arrows: {
    to:     {enabled: true, scaleFactor:1, type:'arrow'},
    middle: {enabled: false, scaleFactor:1, type:'arrow'},
    from:   {enabled: false, scaleFactor:1, type:'arrow'}
  }},
  interaction:{
    navigationButtons: true,
    //  keyboard: true  //incompatible avec rappel de commande en cours d'implémentation
    multiselect: true,
  },

  manipulation: {
    addNode: function (data, callback) {
      // filling in the popup DOM elements
      data.label = "";
      //  console.log(this);
      app.editNode(data, callback);
    },
    editNode: function (data, callback) {
      // filling in the popup DOM elements
      //document.getElementById('nodeOperation').innerHTML = "Edit Node";
      data.edit = true; // signalement d'une edition pour sparql
      console.log(data);
      app.$.nodeOperation.innerHTML = "Editer le noeud";
      app.editNode(data, callback);
    },
    deleteNode: function (data, callback) {
      // filling in the popup DOM elements
      app.deleteNode(data, callback);
    },
    addEdge: function (data, callback) {
      if (data.from == data.to) {
        var r = confirm("Êtes-vous certain de vouloir connecter le noeud à lui-même?");
        if (r != true) {
          callback(null);
          return;
        }
      }
      //document.getElementById('edgeOperation').innerHTML = "Add Edge";
      app.$.edgeOperation.innerHTML = "Ajouter un lien";
      app.editEdgeWithoutDrag(data, callback);
    },
    editEdge: {
      editWithoutDrag: function(data, callback) {
        //document.getElementById('edgeOperation').innerHTML = "Edit Edge";
        data.edit = true; // signalement d'une edition pour sparql
        console.log(data);
        data.oldLabel = data.label;
        app.$.edgeOperation.innerHTML = "Editer le lien";
        app.editEdgeWithoutDrag(data,callback);
      }
    },
    deleteEdge: function(data,callback){
      app.deleteEdge(data,callback);
    }
  },
  physics:{
    enabled: true,
    barnesHut: {
      gravitationalConstant: -1,
      centralGravity: 0.3,
      springLength: 95,
      springConstant: 0.04,
      damping: 0.09,
      avoidOverlap: 1
    },
    forceAtlas2Based: {
      gravitationalConstant: -50,
      centralGravity: 0.01,
      springConstant: 0.08,
      springLength: 100,
      damping: 0.4,
      avoidOverlap: 0
    },
    repulsion: {
      centralGravity: app.centralGravityValueDefault,  //0.001, //0.001 ? A quoi sert cette valeur ?
      springLength: app.springLengthValueDefault,   // 220, //220 (//200 //300)
      springConstant: app.springConstantValueDefault, //0.01, //0.01
      nodeDistance:  app.nodeDistanceValueDefault, //150, //100 //350
      damping: app.dampingValueDefault, ///0.08
    },
    hierarchicalRepulsion: {
      centralGravity: 0.0,
      springLength: 100,
      springConstant: 0.01,
      nodeDistance: 120,
      damping: 0.09
    },
    maxVelocity: 500, //50
    minVelocity: 1, //0.1
    solver: 'repulsion',
    stabilization: {
      enabled: true,
      iterations: 1000,
      updateInterval: 100,
      onlyDynamicEdges: false,
      fit: true
    },
    timestep: 0.5,
    adaptiveTimestep: true
  }
};
console.log(options)
return new vis.Network(container, data, options);
}


editNode (data, callback) {
  console.log(data);
  if (data.title != undefined){
    this.$.nodeLabel.value= data.title.replace(/<br\s*\/?>/mg,"");
  }else{
    this.$.nodeLabel.value=  data.label || "";
  }
  this.selectedShape = data.shape || "ellipse";
  this.selectedType = data.type || "normal";
  this.imageUrl = data.image || "";
  if ((data.color != undefined) && (data.color.background != undefined)){
    this.colorValue = data.color.background
  }
  else{
    this.colorValue =   "rgb(173,208,255)";
  }
  this.$.nodeSaveButton.onclick = this.saveNodeData.bind(this, data, callback);
  this.$.nodeCancelButton.onclick = this.cancelNodeEdit.bind(this, callback);
  this.$.nodePopUp.toggle(); //style.display = 'block';
}




clearNodePopUp () {
  this.$.nodeSaveButton.onclick = null;
  this.$.nodeCancelButton.onclick = null;
  //  this.$.nodePopUp.toggle();//style.display = 'none';
}
cancelNodeEdit (callback) {
  this.clearNodePopUp(this);
  callback(null);
}
saveNodeData (data, callback) {
  /*
  let dataTemp = data;
  let cb = callback;
  console.log(dataTemp);
  console.log(cb);
  console.log(data.type);
  data et callback apparaissent comme des events ?????
  {id: "38e05a49-feb0-4d65-a35f-c7c7d973390e", x: -518.5339336634761, y: -388.3170534287593, label: ""}
  spoggy-graph.html:373 Event {isTrusted: false, detail: {…}, type: "tap", target: paper-button#nodeSaveButton, currentTarget: paper-button#nodeSaveButton, …}
  spoggy-graph.html:374 {x: 138, y: 588, sourceEvent: MouseEvent, preventer: undefined}preventer: undefinedsourceEvent: MouseEvent {isTrusted: true, __polymerGesturesHandled: {…}, screenX: 2058, screenY: 654, clientX: 138, …}x: 138y: 588__proto__: Object
  spoggy-graph.html:378 tap
  */

  data.label = this.$.nodeLabel.value;
  data.shape = this.selectedShape;
  data.color = this.colorValue;
  data.image = this.$.imgUrl.value;

  data.type = this.selectedType;
  if (data.label.length > 40){
    var titleTemp =data.label.match(/.{1,40}/g);
    //  console.log(titleTemp);
    data.title = titleTemp.join("<br>");
    data.label = titleTemp[0]+'...';
    data.shape = "box";
    //  data.mass = 1/data.label.length
  }
  this.clearNodePopUp(this);
  callback(data);
  var node = this.network.body.data.nodes.get(data.id);
  console.log(node);
  var action = {};
  action.type = "newNode";
  action.data = node;
  console.log
  this.agentGraph.send('agentSocket', {type: "newActions", actions: [action]});
  this.agentGraph.send('agentSparqlUpdate', {type: "newActions", actions: [action]});
  if( data.type == "graph"){
    console.log("nodeID");
    console.log(node.id);
    var graphNode = this.network.body.data.nodes.get({
      filter: function(node){
        console.log(node);
        return (node.label == "Graph" );
      }
    });
    console.log(graphNode);
    if (graphNode.length == 0){
      console.log("creation du noeud graph");
      var nodeGraph = {};
      nodeGraph.label = "Graph";
      nodeGraph.shape = "star";
      nodeGraph.type = "node";
      nodeGraph.color= "rgb(255,0,0)";
      this.network.body.data.nodes.add(nodeGraph);
    }else{
      console.log("récupération du noeud graph");
    }
    graphNode = this.network.body.data.nodes.get({
      filter: function(node){
        console.log(node);
        return (node.label == "Graph" );
      }
    });
    var actionNodeGraph = {};
    actionNodeGraph.type = "newNode";
    actionNodeGraph.data = graphNode[0];
    //  this.addAction(actionNodeGraph);
    this.agentGraph.send('agentSocket', {type: "newActions", actions: [actionNodeGraph]});
    this.agentGraph.send('agentSparqlUpdate', {type: "newActions", actions: [actionNodeGraph]});
    console.log(graphNode);
    console.log(node.id);
    var edgeGraph = {};
    edgeGraph.from = node.id;
    edgeGraph.to = graphNode[0].id;
    edgeGraph.label = "type";
    var graphEdge = this.network.body.data.edges.get({
      filter: function(edge){
        console.log(edge);
        return (edge.from == edgeGraph.from && edge.to == edgeGraph.to && edge.label == edgeGraph.label);
      }
    });
    console.log(graphEdge);
    if(graphEdge.length == 0){
      this.network.body.data.edges.add(edgeGraph);
    }
    graphEdge = this.network.body.data.edges.get({
      filter: function(edge){
        console.log(edge);
        return (edge.from == edgeGraph.from && edge.to == edgeGraph.to && edge.label == edgeGraph.label);
      }
    });
    console.log("EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEee");
    console.log(graphEdge);
    var actionedgeGraph = {};
    actionedgeGraph.type = "newEdge";
    actionedgeGraph.data = graphEdge;
    //    this.addAction(actionedgeGraph);
    this.agentGraph.send('agentSocket', {type: "newActions", actions: [action]});
    this.agentGraph.send('agentSparqlUpdate', {type: "newActions", actions: [action]});
  }
  /*
  if( data.type == "graph"){
  var graphNode = this.network.body.data.nodes.get({
  filter: function(node){
  console.log(node);
  return (node.label == "Graph" );
}
});
console.log(graphNode);
var n ;
if(graphNode.length==0){
console.log("creation");
// creation du noeud Graph
var nodeGraph = {};
nodeGraph.label = "Graph";
nodeGraph.shape = "star";
n= this.network.body.data.nodes.add(nodeGraph)[0];
}else{
console.log("exist");
n = graphNode[0].id;
}
console.log(n);
var actionTo = {};
actionTo.type = "newNode";
actionTo.data = this.network.body.data.nodes.get(n);
console.log(actionTo);
this.addAction(actionTo);
var edgeGraph = {};
edgeGraph.label = "type";
edgeGraph.from = data.id;
edgeGraph.to = n;
this.addEdgeIfNotExist(this.network, edgeGraph);
var edge;
var existEdge = this.network.body.data.edges.get({
filter: function(edge){
return (edge.from == edgeGraph.from && edge.to == edgeGraph.to && edge.label == edgeGraph.label);
}
});
console.log(existEdge);
if(existEdge.length == 0){
edge = this.network.body.data.edges.update(edgeGraph);
}else{
edge = existEdge[0];
}
console.log(edge);
var actionGraph = {};
actionGraph.type = "newEdge";
//var e= this.network.body.data.edges.update(edgeGraph);
var e = this.network.body.data.edges.get(edge[0]);
console.log(e);
actionGraph.data = e;
console.log(actionGraph);
this.addAction(actionGraph);
*/
//}
/*this.nodes = [];
this.nodes = this.network.body.data.nodes;*/
}



editEdgeWithoutDrag (data, callback) {
  this.$.edgeLabel.value = data.label || "";
  this.$.edgeSaveButton.onclick = this.saveEdgeData.bind(this, data, callback);
  this.$.edgeLabel.onchange = this.saveEdgeData.bind(this, data, callback);
  this.$.edgeCancelButton.onclick = this.cancelEdgeEdit.bind(this,callback);
  this.$.edgePopUp.toggle(); //style.display = 'block';
}
clearEdgePopUp () {
  this.$.edgeSaveButton.onclick = null;
  this.$.edgeCancelButton.onclick = null;
  //  this.$.edgePopUp.toggle(); //style.display = 'none';
}
cancelEdgeEdit (callback) {
  this.clearEdgePopUp();
  callback(null);
}
saveEdgeData (data, callback) {
  if (typeof data.to === 'object')
  data.to = data.to.id
  if (typeof data.from === 'object')
  data.from = data.from.id
  data.label = this.$.edgeLabel.value;
  this.clearEdgePopUp();
  console.log(callback)
  if (typeof callback == 'function'){
    callback(data);
  }

  var edge = this.network.body.data.edges.get({
    filter: function(edge) {
      return (edge.from == data.from && edge.to == data.to && edge.label == data.label);
    }
  });
  var action = {};
  action.type = "newEdge";
  action.data = edge;
  //  this.addAction(action);
  this.agentGraph.send('agentSocket', {type: "newActions", actions: [action]});
  this.agentGraph.send('agentSparqlUpdate', {type: "newActions", actions: [action]});
}
deleteNode (data, callback){
  var action = {};
  action.type = "deleteNode";
  action.data = data;
  //  this.addAction(action);
  this.agentGraph.send('agentSocket', {type: "newActions", actions: [action]});
  this.agentGraph.send('agentSparqlUpdate', {type: "newActions", actions: [action]});
  callback(data);
}
deleteEdge (data, callback){
  var action = {};
  action.type = "deleteEdge";
  action.data = data;
  //  this.addAction(action);
  this.agentGraph.send('agentSocket', {type: "newActions", actions: [action]});
  this.agentGraph.send('agentSparqlUpdate', {type: "newActions", actions: [action]});
  callback(data);
}

addEdgeIfNotExist (network, data){
  var existEdge = false;
  console.log(data);
  try {
    existEdge = this.network.body.data.edges.get({
      filter: function(edge){
        return (edge.id == data[0].id);
      }
    });
    if (existEdge.length == 0){
      this.network.body.data.edges.add(data[0]);
    }else{
      this.network.body.data.edges.update({id: data[0].id, label: data[0].label});
    }
  }
  catch (err) {
    console.log(err);
  }
}
addNodeIfNotExist(network, data){
  var existNode = false;
  //console.log(data);
  var nodeId;
  try{
    existNode = network.body.data.nodes.get({
      filter: function(n){
        return (n.id == data.id || (n.label == data.label)); //  || n.title == data.label
      }
    });
    //console.log(existNode);
    if (existNode.length == 0){
      //  console.log("n'existe pas")
      nodeId =   network.body.data.nodes.add(data)[0];
    }else{
      //  console.log("existe")
      delete data.x;
      delete data.y
      nodeId =  network.body.data.nodes.update(data)[0];
    }
  }
  catch (err){
    console.log(err);
  }
  /*  console.log("GESTION TYPE RESOURCE")
  console.log(nodeId)
  //AJOUT du noeud resourceType
  if (data.resourceType != undefined){
  console.log("ajout "+data.resourceType +" à "+ nodeId)
  var nodeResource = {
  label : data.resourceType
}
var nodeIdResourceType =  this.addNodeIfNotExist(network, nodeResource);

console.log("TYPE de  "+nodeId +" à "+ nodeIdResourceType)
var edge = {
from: nodeId,
to: nodeIdResourceType,
label: "type"
}
this.addEdgeIfNotExist(network,edge)
}

return nodeId;*/

}




_inferedChanged(newInfered,oldinfered){
  console.log("INFERED");
  console.log(newInfered);
  this.populateFromInfered(newInfered, this.network)
}


populateFromInfered(infered, network){
  if(network != undefined){
    console.log(infered);
    if(infered.length != 0){
      infered.forEach(function(triplet){
        //var triplet = infered.pop();
        console.log(triplet);
        if (triplet != undefined) {
          console.log(infered.length);
          var sujet = triplet[0].trim();
          var propriete = triplet[1].trim();
          var objet = triplet[2].trim();
          var sujetExist = network.body.data.nodes.get({
            filter: function(node){
              //    console.log(node);
              return (node.label == sujet );
            }
          });
          var objetExist = network.body.data.nodes.get({
            filter: function(node){
              //    console.log(node);
              return (node.label == objet );
            }
          });
          if(sujetExist == null  || sujetExist.length == 0){
            console.log("creation "+sujet);
            var node = {
              label: sujet,
              group: 100, // règles
              borderWidth: 2,
              shape: "diamond",
              color: "rgb(255,153,30)"
            };
            network.body.data.nodes.add(node);
          }else{
            console.log(sujet+ " exist");
            console.log(sujetExist);
            //  network.body.data.nodes.update({id: sujetExist[0].id, group: 1,borderWidth: 2,shape: "diamond"});
          }
          if(objetExist == null  || objetExist.length == 0){
            console.log("creation "+objet);
            var node = {
              label: objet,
              group: 100,
              borderWidth: 2,
              shape: "diamond",
              color: "rgb(255,153,30)"
            };
            network.body.data.nodes.add(node);
          }else{
            console.log(objet+ " exist");
            console.log(objetExist);
            //  network.body.data.nodes.update({id: sujetExist[0].id, group: 1,borderWidth: 2,shape: "diamond"});
          }
          sujetExist = network.body.data.nodes.get({
            filter: function(node){
              //    console.log(node);
              return (node.label == sujet );
            }
          });
          objetExist = network.body.data.nodes.get({
            filter: function(node){
              //    console.log(node);
              return (node.label == objet );
            }
          });
          var edgeExist = network.body.data.edges.get({
            filter: function(edge) {
              return (edge.from == sujetExist[0].id && edge.to == objetExist[0].id && edge.label == propriete);
            }
          });
          if (edgeExist == null || edgeExist.length == 0) {
            var edge = {
              from: sujetExist[0].id,
              to: objetExist[0].id,
              label: propriete,
              group: 100, // règles
              arrows: "to",
              color: "rgb(255,153,30)"
            };
            //edge.id = triplet.subject;
            //edge[triplet.predicate] = triplet.object;
            console.log("add");
            console.log(edge);
            network.body.data.edges.add(edge);
          } else {
            console.log("update");
            console.log(edgeExist);
            //var edge = edgeExist;
            //edge[triplet.predicate] = triplet.object;
            //  network.body.data.edges.update(edge);
          }
        }
      });
    }
    else{
      console.log("suppression des inférences");
      var edgesInferres = network.body.data.edges.get({
        filter: function(edge){
          //    console.log(node);
          return (edge.group == 100 );
        }
      });
      console.log(edgesInferres);
      network.body.data.edges.remove(edgesInferres);
      var nodesInferres = network.body.data.nodes.get({
        filter: function(node){
          //    console.log(node);
          return (node.group == 100 );
        }
      });
      console.log(nodesInferres);
      network.body.data.nodes.remove(nodesInferres);
    }
  }
}
// CLUSTERS
_toggleDesc() {
  //  network.setData(data);
  var clusterOptionsByData = {
    joinCondition:function(childOptions) {
      return childOptions.cid == 1;
    },
    processProperties: function (clusterOptions, childNodes) {
      //clusterIndex = clusterIndex + 1;
      var clusterIndex = 1
      var childrenCount = 0;
      for (var i = 0; i < childNodes.length; i++) {
        childrenCount += childNodes[i].childrenCount || 1;
      }
      clusterOptions.childrenCount = childrenCount;
      clusterOptions.label = "Description\n# " + childrenCount + "";
      // clusterOptions.font = {size: childrenCount*5+30}
      clusterOptions.id = 'cluster:' + clusterIndex;
      clusterOptions.mass = 1/childrenCount;
      // clusters.push({id:'cluster:' + clusterIndex, scale:scale});
      return clusterOptions;
    },
    clusterNodeProperties: {id:'cidCluster',  color: 'rgba(97,238,195,0.5)', borderWidth:3, shape:'box'}
  };
  this.network.cluster(clusterOptionsByData);
}
_closeImportPopUp(){
  this.$.importPopUp.toggle(); //.style.display = 'none';
}
/*_toogle() {
console.log("clic");
this.$.nodePopUp.toggle();
}*/




recupParams(){
  var params = (function(a) {
    if (a == "") return {};
    var b = {};
    for (var i = 0; i < a.length; ++i)
    {        var p=a[i].split('=', 2);
    if (p.length == 1)
    b[p[0]] = "";
    else
    b[p[0]] = decodeURIComponent(p[1].replace(/\+/g, " "));
  }
  return b;
})(window.location.search.substr(1).split('&'));
return params;
}

/*currentChanged(current){
console.log(current)
if ((current.key == "folder") ||(current.type == "folder")) {
this.folder2vis(current.value)
}else if ((current.key == "file") || (current.type == "folder")){
this.file2vis(current)
}else{
console.log("Current.key inconnu",current)
}
}*/

folder2vis(sfolder){
  var app = this;
  //  this.clear()
  console.log('sfolder')
  console.log(sfolder)
  var name = sfolder.name;
  var url = sfolder.url;
  var parent = sfolder.parent;
  //  var folders = sfolder.folders||"Folders";
  //  var files = sfolder.files|| "Files";

  var nodes = [];
  var edges = [];
  nodes.push({id: url, label: name, type: "folder", shape: "image", image: "./assets/folder.png" });
  //nodes.push({id:'folders', label:"Folder"});
  //edges.push({from:url, to: 'folders', arrows: 'to', label:"type"});
  //console.log("PAREnT", parent)

  if (parent != undefined){
    //  console.log("undef")
    nodes.push({id: parent, label: parent, type: "folder", shape: "image", image: "./assets/parentfolder.png" });
    edges.push({from: url, to: parent, arrows:'to', label: "parent"});
  }
  //  {id: "urlNode"+url, label: url},
  /*,
  {id: "folderCluster", label: folders},
  {id: "fileCluster", label: files}*/


  // create an array with edges

  //{from: url, to: "urlNode"+url, arrows:'to', label: "url"},
  /*,
  {from: url, to: "folderCluster", arrows:'to', label: "folders"},
  {from: url, to: "fileCluster", arrows:'to', label: "files"},*/


  if (sfolder.folders && sfolder.folders.length >0){

    sfolder.folders.forEach(function(fo){
      if(fo.name != ".."){
        app.folder2vis(fo)
        var node = {id:fo.url, label:fo.name, type: 'folder', shape: "image", image: "./assets/folder.png" }
        //  console.log(node)
        nodes.push(node);
        edges.push({from:url, to: fo.url, arrows: 'to', label:"folder"});
        edges.push({from:fo.url, to: 'folders', arrows: 'to', label:"type"});
      }
    })
  }
  if (sfolder.files && sfolder.files.length > 0){
    //  nodes.push({id:'files', label:"File"});
    sfolder.files.forEach(function(fi){
      //  console.log(fi)
      //  app.file2vis(fi)
      var node = {id:fi.url, label:fi.label, type: 'file' , shape: "image", image: "./assets/document.png" };
      //  console.log(node)
      nodes.push(node);
      edges.push({from:url, to: fi.url, arrows: 'to', label:"file"});
      //  edges.push({from:fi.url, to: 'files', arrows: 'to', label:"type"});
    })
  }

  var  data = {
    nodes: nodes,
    edges: edges
  };
  //  console.log(data)
  this.network.body.data.nodes.clear();
  this.network.body.data.edges.clear();
  this.addSolidToGraph(data);
  this.network.fit();
  this.network.redraw();
}

addSolidToGraph(data){
  //console.log(data)

  this.network.body.data.nodes.update(data.nodes)
  this.network.body.data.edges.update(data.edges)
}

/*file2vis(sfile){
console.log('sfile',sfile)
this.fileChanged(sfile);
}*/


fileChanged(file){
  //  this.clear()
  console.log(file);

  //this.url = file.url;
  console.log(file.type)


  switch(file.type) {
    case "application/json":
    this.parseJson(file)
    break;
    case "text/turtle":
    this.parseTurtle(file)
    break;
    default:
    this.parseTurtle(file)
  }

}

clear(){
  this.network.body.data.nodes.clear();
  this.network.body.data.edges.clear();
  this.network.fit();
  this.network.redraw();
}
parseJson(file){
  console.log("JSON\n\n")

  this.fileclient.readFile( file.url ).then( response => {
    if(!response)
    { console.log(this.fileclient.err)}
    else {
      console.log( `File content is : ${response.value}.`)

      //  this.content = response.value;
      //this.agentEditor.send('agentGraph', {type: 'fileChanged', file: file })
      //  console.log(data)
      var data = JSON.parse(response.value);
      console.log(data)
      //  console.log(typeof data)
      this.network.body.data.nodes.update(data.nodes)
      this.network.body.data.edges.update(data.edges)
      /*  console.log(data.nodes)
      console.log(data.edges)
      data.nodes.forEach(function(n){
      console.log(n)
    })

    data.edges.forEach(function(e){
    console.log(e)
  })*/
}
})


}



parseTurtle(file){
  console.log("Parse turtle INUTILE ???")
  var app = this;
  console.log(file)
  var params = {}
  params.source = file.url;
  //  this.importFromParam(params)




  //  console.log(file.value.content)
  //  ttl2Xml(file.value.content, this.network)
  /* TEST AVEC STORE+SPARQL, mais on a dejà les infos dans file.value.content */

  /*this.fileclient.readFile( file.url ).then( response => {
  if(!response)
  { console.log(this.fileclient.err)}
  else {
  console.log( `File content is : ${response.value}.`)
  console.log( "Response : ",response)
}
});*/



///////////////// V1
/*const store = $rdf.graph();
//  console.log(store)
const fetcher = new $rdf.Fetcher(store);
//  console.log(fetcher)
fetcher.load(file.url).then( response => {
//  console.log(response)
//  console.log(store)
//  console.log(store.statements)
var edges=[];
//  console.log(store.statements)
if (store.statements.length > 0){
store.statements.forEach(function (s){
console.log("STATEMENT2VIS", s)
console.log("sujet",s.subject)
var nodeSujetTemp = {
id: s.subject.value,
title: s.subject.value,
label: app.localname(s.subject),
type: "node"
};
console.log(nodeSujetTemp)

console.log("objet",s.object)
var nodeObjetTemp = {
id:  s.object.value,
title: s.object.value,
label: app.localname(s.object),
type: "node"
};

console.log(nodeObjetTemp)
app.addNodeIfNotExist(app.network, nodeSujetTemp)
app.addNodeIfNotExist(app.network, nodeObjetTemp)
edges.push({from:s.subject.value, to: s.object.value, arrows: 'to', label:s.predicate.value});
console.log(edges)
app.network.body.data.edges.update(edges)
})}
})*/
/*let name = store.any(person, VCARD(‘fn’));
if (name) {
label.textContent =  name.value; // name is a Literal object
}*/
}

localname(node){
  console.log("LOCALNAME OF ",node)
  var labelU = node.value;
  if (node.termType == "NamedNode"){
    console.log("namenode")
    var uLabel = node.value.split("#");
    var labelU = uLabel[uLabel.length-1];
    if (labelU == uLabel){
      uLabel = node.value.split("/");
      labelU = uLabel[uLabel.length-1];
    }
  }else{
    console.log("literal or blanknode ???")
  }
  console.log(labelU)
  return labelU;
}

async nodeChanged(node){
  var current = {};
  var app = this;
  current.url = node.id;
  current.type = node.type;

  if (node.type == "folder"){
    this.fileclient.readFolder( node.id ).then( folder => {
      if(!folder){
        console.log("ce n'est pas un folder")
        console.log(this.fileclient.err)
      }
      else {
        console.log(`Read ${folder.name}, it has ${folder.files.length} files.`)
        this.agentGraph.send('agentEditor', {type: "folderChanged", folder: folder});

        //    this.agentGraph.send('agentGraph', {type: 'folderChanged', folder: folder })

        console.log(folder)}
      })
    }else if (node.type == "file"){
      this.fileclient.fetchAndParse(node.id).then( response => {
        if(!response) {
          alert("Couldn't fetch or parse RESP : "+this.fileclient.err)
        }
        else {
          console.log("RESP")
          console.log(response)
          console.log(response.statements)

          app.network.body.data.nodes.clear();
          app.network.body.data.edges.clear();


          response.statements.forEach(function (statement){
            console.log("STATEMENT2VIS", statement)
            var edges = [];
            var s = statement.subject;
            var p = statement.predicate;
            var o = statement.object;
            var w = statement.why;

            switch(p.value) {
              case "http://www.w3.org/2000/01/rdf-schema#label":
              //  console.log("LABEL")
              //  console.log(s.value)
              //  console.log(o.value)
              var nodeAndLabel = {
                id: s.value,
                title: o.value,
                label: o.value,
                why: w.value,
                y:2*Math.random(),
                type: "node"
              };
              console.log(nodeAndLabel)
              app.addNodeIfNotExist(app.network, nodeAndLabel)
              break;
              default:
              console.log("NON LABEL ",p.value);
              var edges = [];
              var nodeSujetTemp;
              if (s.termType != "BlankNode"){
                var ls = app.localname(s);
                console.log(ls)
                nodeSujetTemp = {
                  id: s.value,
                  title: s.value,
                  label: ls,
                  why: w.value,
                  y:2*Math.random(),
                  type: "node"
                };
                console.log(nodeSujetTemp)
                app.addNodeIfNotExist(app.network, nodeSujetTemp)
              }/*else{
                nodeSujetTemp = {
                id: s.value,
                type: "node"
              };
            }*/


            console.log("objet",o)
            if (o.termType != "BlankNode"){
              var lo = app.localname(o);
              console.log(lo)
              var nodeObjetTemp = {
                id:  o.value,
                title: o.value,
                label: lo,
                why: w.value,
                type: "node"
              };
              console.log(nodeObjetTemp)
              app.addNodeIfNotExist(app.network, nodeObjetTemp)
            }

            /*  let pArray = p.split("#");
            //  console.log(conceptCut);
            let labelP = pArray[pArray.length-1];
            if (labelP == p){
            pArray = p.split("/");
            //console.log(conceptCut);
            labelP = pArray[pArray.length-1];
          }*/

          edges.push({from:s.value, to: o.value, arrows: 'to', label: app.localname(p), uri: p.value});
          //  app.addEdgeIfNotExist(app.network,{from:s.subject.value, to: s.object.value, arrows: 'to', label:s.predicate.value});
          console.log(edges)
          app.network.body.data.edges.update(edges)
        }
      });





      /*console.log("sujet",s.subject)
      var ls = app.localname(s.subject);
      console.log(ls)
      var nodeSujetTemp = {
      id: s.subject.value,
      title: s.subject.value,
      label: ls,
      type: "node"
    };
    console.log(nodeSujetTemp)

    console.log("objet",s.object)
    var lo = app.localname(s.object);
    console.log(lo)
    var nodeObjetTemp = {
    id:  s.object.value,
    title: s.object.value,
    label: lo,
    type: "node"
  };

  console.log(nodeObjetTemp)
  app.addNodeIfNotExist(app.network, nodeSujetTemp)
  app.addNodeIfNotExist(app.network, nodeObjetTemp)
  edges.push({from:s.subject.value, to: s.object.value, arrows: 'to', label:s.predicate.value});
  //  app.addEdgeIfNotExist(app.network,{from:s.subject.value, to: s.object.value, arrows: 'to', label:s.predicate.value});
  console.log(edges)
  app.network.body.data.edges.update(edges)
})*/

//  this.agentGraph.send('agentEditor', {type: "fileChanged", file: current});
//  this.agentBrowser.send('agentGraph', {type: 'fileChanged', file: current })
//  this.agentGraph.send('agentFoldermenu', {type: 'folderChanged', folder: folder });
//  console.log(graph.statements)
//  let something = graph.any(someSubject,somePredicate)
/*  var contentType = response.headers.get("content-type");
console.log(contentType)
if(contentType && contentType.indexOf("application/json") !== -1) {
return response.json().then(function(json) {
// traitement du JSON
console.log("C'est du JSON!");
});
} else {
console.log("Oops, nous n'avons pas du JSON!");
}*/
}
})
}else{
  console.log("node.type inconnu", node)
}
this.agentGraph.send('agentBrowser', {type: 'currentChanged', current: current });
/*

console.log("-boo-")

this.fileclient.readFile( node.id ).then( response => {
if(!response) console.log(this.fileclient.err)
else console.log( `File content is : ${response.value}.` )
})

this.fileclient.fetchAndParse(node.id,'text/turtle').then( graph => {
if(!graph) alert("Couldn't fetch or parse : "+this.fileclient.err)
else {
console.log(graph)
console.log(graph.statements)
//  let something = graph.any(someSubject,somePredicate)
}
})*/


/*this.fileclient.fetch( node.id ).then( results => {
if(!results) {alert("Could not fetch "+node.id+" "+fileClient.err)}
else {
console.log(results)
}
})*/

/*var thing = {};
thing.url = node.id;
this.current =  await this.st.get(thing);
console.log("RESULT : ",this.current)
this.agentGraph.send('agentCurrent', {type: 'currentChanged', current: this.current });
this.agentGraph.send('agentFileeditor', {type: 'currentChanged', current: this.current });
this.agentGraph.send('agentFoldermenu', {type: 'currentChanged', current: this.current });
this.currentChanged(this.current)*/
}

}
});
</script>
